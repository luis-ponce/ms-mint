{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MINT - Metabolomics Integrator MINT is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. Metabolites can be used to define biomarkers used in medicine for both finding treatments for diseases, the development of diagnostic tests, as well as the identification of pathogens such as methicillin-resistant Staphylococcus aureus (MRSA). Figure 1: Flowchart of MINT processing workflow. How to use MINT? The tool can be used for targeted and untargeted analysis. In the first case, the m/z values (mass to charge ratios) and the chromatographic retention times are previously known. In the second approach, new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterize measured intensities in a given m/z and retention time (RT) window. RT windows can be provided in form of a peaklist or created interactively in the graphical user interface GUI . With this setup, large numbers of LCMS files can be processed automatically and standardized in a perfectly reproducible manner. The tool can be used with a browser-based GUI, implemented as an interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as a python library to be integrated into any regular Python code as part of a larger processing pipeline or interactively in the Jupyter Notebook .","title":"Home"},{"location":"#mint-metabolomics-integrator","text":"MINT is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. Metabolites can be used to define biomarkers used in medicine for both finding treatments for diseases, the development of diagnostic tests, as well as the identification of pathogens such as methicillin-resistant Staphylococcus aureus (MRSA). Figure 1: Flowchart of MINT processing workflow.","title":"MINT - Metabolomics Integrator"},{"location":"#how-to-use-mint","text":"The tool can be used for targeted and untargeted analysis. In the first case, the m/z values (mass to charge ratios) and the chromatographic retention times are previously known. In the second approach, new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterize measured intensities in a given m/z and retention time (RT) window. RT windows can be provided in form of a peaklist or created interactively in the graphical user interface GUI . With this setup, large numbers of LCMS files can be processed automatically and standardized in a perfectly reproducible manner. The tool can be used with a browser-based GUI, implemented as an interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as a python library to be integrated into any regular Python code as part of a larger processing pipeline or interactively in the Jupyter Notebook .","title":"How to use MINT?"},{"location":"background/","text":"Background What is LCMS? A typical biological sample, such as human blood or agar with some kind of bacteria, contains thousands of metabolites including sugars, alcohols, amino acids, nucleotides, among others. Mass spectrometry is one of the most popular techniques for the assessment of the composition of biological samples. Many metabolites share exact masses with other metabolites and therefore would be indistinguishable in the mass spectrometer. For this reason, compounds are sorted using a column chromatography and spread out over time. Metabolites entering into the column at the same time interact with the column matrix in different ways which makes them move faster or slower through the column and elude at different times. In this way, various metabolites can be analyzed successively over different timeframes rather than simultaneously. The mass spectrometer that follows the chromatographic column (LCMS) measures the masses given at each point in time and returns a time-dependent spectrogram. An example of an LSMS measurement can be visualized in the following figure: Figure 1: A 2D-histogram of a MS1 recorded intensities taken over time span of 10 minutes. Shown are m/z values between 100 and 600 [Da/z]. If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or (or succinic acid ) is shown here: Figure 2: A zoom into the 2D histogram shown in figure 1. This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4. Processing LCMS data After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor-specific format, it can be subjected to analysis. To process the data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analyzing the raw LCMS data, it is common practice to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the measured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiencies compound A might have a stronger signal than compound B even if compound B is present at a higher concentration. Therefore, the intensities can only be used to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often, the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data analyses such as dimensionality reduction, or clustering. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: E. coli , SA: S. aureus , CA: C. albicans ).","title":"Background"},{"location":"background/#background","text":"","title":"Background"},{"location":"background/#what-is-lcms","text":"A typical biological sample, such as human blood or agar with some kind of bacteria, contains thousands of metabolites including sugars, alcohols, amino acids, nucleotides, among others. Mass spectrometry is one of the most popular techniques for the assessment of the composition of biological samples. Many metabolites share exact masses with other metabolites and therefore would be indistinguishable in the mass spectrometer. For this reason, compounds are sorted using a column chromatography and spread out over time. Metabolites entering into the column at the same time interact with the column matrix in different ways which makes them move faster or slower through the column and elude at different times. In this way, various metabolites can be analyzed successively over different timeframes rather than simultaneously. The mass spectrometer that follows the chromatographic column (LCMS) measures the masses given at each point in time and returns a time-dependent spectrogram. An example of an LSMS measurement can be visualized in the following figure: Figure 1: A 2D-histogram of a MS1 recorded intensities taken over time span of 10 minutes. Shown are m/z values between 100 and 600 [Da/z]. If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or (or succinic acid ) is shown here: Figure 2: A zoom into the 2D histogram shown in figure 1. This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4.","title":"What is LCMS?"},{"location":"background/#processing-lcms-data","text":"After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor-specific format, it can be subjected to analysis. To process the data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analyzing the raw LCMS data, it is common practice to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the measured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiencies compound A might have a stronger signal than compound B even if compound B is present at a higher concentration. Therefore, the intensities can only be used to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often, the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data analyses such as dimensionality reduction, or clustering. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: E. coli , SA: S. aureus , CA: C. albicans ).","title":"Processing LCMS data"},{"location":"developer-notes/","text":"Developer Notes python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-* Windows executables pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks Documentation deployment mkdocs build && mkdocs gh-deploy Example NGINX config location /mint/ { client_max_body_size 10G; proxy_pass http://localhost:9999; #rewrite ^/mint/(.*) /$1 break; proxy_http_version 1.1; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 86400; } Then start MINT with --serve-path='\\mint\\' . Additional packages To run tests and code optimization you need the following packages: conda install flake8 pytest mkdocs","title":"Developer Notes"},{"location":"developer-notes/#developer-notes","text":"python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-*","title":"Developer Notes"},{"location":"developer-notes/#windows-executables","text":"pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks","title":"Windows executables"},{"location":"developer-notes/#documentation-deployment","text":"mkdocs build && mkdocs gh-deploy","title":"Documentation deployment"},{"location":"developer-notes/#example-nginx-config","text":"location /mint/ { client_max_body_size 10G; proxy_pass http://localhost:9999; #rewrite ^/mint/(.*) /$1 break; proxy_http_version 1.1; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 86400; } Then start MINT with --serve-path='\\mint\\' .","title":"Example NGINX config"},{"location":"developer-notes/#additional-packages","text":"To run tests and code optimization you need the following packages: conda install flake8 pytest mkdocs","title":"Additional packages"},{"location":"docker/","text":"","title":"Docker"},{"location":"gui/","text":"MINT GUI Workspaces Add new workspaces Delete workspaces Activate workspace A workspace is a container for project files that is separated from other workspaces. Through workspaces, it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which, by default, is the folder MINT in the user\u2019s home directory. The home directory is different on different platforms. Under Windows the default folder is: C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace, the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. The DELETE button will display a popup window upon confirmation the selected workspace with all corresponding files on the hard drive in --data-dir will be removed. MS-files Import mass spectrometry files (MS-file) in mzXML or mzML format Convert file to feather format (other formats will be removed) Remove MS-files from workspace Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This process will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. Feather is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after conversion. Metadata Select samples used for peak optimization by setting values in the column PeakOpt to True . Add batch labels to analyze for possible batch effects. Add labels to analyze for differences of different groups (e.g. treatment and control) Add types for different files e.g. biological sample, quality control sample, standards etc in order to include ore exclude certain types during analysis. Add other types of metadata. Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch, label, or types. Peaklist Import peaklist from CSV file or add new peaks manually Rename peaks definitions or change parameters Delete peak definitions Add Metabolites Search for metabolites from ChEBI three stars database Add selected metabolites to peaklist (without RT estimation) Peak Optimization Optimize retention times for all peaks or individual peaks Preview all peakshapes with quality indicator Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, the aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the currently loaded peaklist. The GENERATE PEAK PREVIEWS tab generates a preview of all peak definitions and plots corresponding to chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifies the closest peak with respect to the expected RT which is displayed as a black vertical line. Manual (interactive) peak optimization Optimize individual peaks one by one Find bad peaks Remove peaks from peaklist Set expected retention time When a peak is selected in the drop-down box, the chromatograms for the particular mass windows using the peak width as defined in the peaklist are extracted and displayed. The current rt window is visualized as a green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly. Processing Run MINT (apply the extraction protocol to all files in the workspace) Download results Reset results and start again When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS files in the workspace and extract additional properties. When the results tables are present, the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button. Analysis After running MINT the results can be downloaded or analyzed using the provided tools. For quality control purposes, histograms and box plots can be generated in the quality control tab. The interactive heatmap tool can be used to explore the results data after RUN MINT has been executed. The tool allows exploring the generated data in form of heatmaps. General selection elements Include/exclude file types (based on Type column in metadata) Include/exclude peak labels for analysis Set file sorting (e.g. by name, by batch etc.) Select group-by column for coloring and statistics Heatmap The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes how the heatmap is generated. Normalized by biomarer: devide values by column maxium. Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time. Correlation of (scaled) peak_max Distributions Plot histograms Density distributions Boxplots The MS files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows selecting one or multiple kinds of graphs to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if this type is defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite. PCA Perform Principal Component Analysis (PCA) Plot projections to first N principal components Contributions of original variables to each component. Hierarchical clustering Plotting MINT comes with a flexible and powerful plotting interface that is based on the powerful Seaborn library. Bar plots Violin plots Boxen plot Scatter plots and more...","title":"GUI"},{"location":"gui/#mint-gui","text":"","title":"MINT GUI"},{"location":"gui/#workspaces","text":"Add new workspaces Delete workspaces Activate workspace A workspace is a container for project files that is separated from other workspaces. Through workspaces, it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which, by default, is the folder MINT in the user\u2019s home directory. The home directory is different on different platforms. Under Windows the default folder is: C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace, the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. The DELETE button will display a popup window upon confirmation the selected workspace with all corresponding files on the hard drive in --data-dir will be removed.","title":"Workspaces"},{"location":"gui/#ms-files","text":"Import mass spectrometry files (MS-file) in mzXML or mzML format Convert file to feather format (other formats will be removed) Remove MS-files from workspace Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This process will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. Feather is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after conversion.","title":"MS-files"},{"location":"gui/#metadata","text":"Select samples used for peak optimization by setting values in the column PeakOpt to True . Add batch labels to analyze for possible batch effects. Add labels to analyze for differences of different groups (e.g. treatment and control) Add types for different files e.g. biological sample, quality control sample, standards etc in order to include ore exclude certain types during analysis. Add other types of metadata. Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch, label, or types.","title":"Metadata"},{"location":"gui/#peaklist","text":"Import peaklist from CSV file or add new peaks manually Rename peaks definitions or change parameters Delete peak definitions","title":"Peaklist"},{"location":"gui/#add-metabolites","text":"Search for metabolites from ChEBI three stars database Add selected metabolites to peaklist (without RT estimation)","title":"Add Metabolites"},{"location":"gui/#peak-optimization","text":"Optimize retention times for all peaks or individual peaks Preview all peakshapes with quality indicator Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, the aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the currently loaded peaklist. The GENERATE PEAK PREVIEWS tab generates a preview of all peak definitions and plots corresponding to chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifies the closest peak with respect to the expected RT which is displayed as a black vertical line.","title":"Peak Optimization"},{"location":"gui/#manual-interactive-peak-optimization","text":"Optimize individual peaks one by one Find bad peaks Remove peaks from peaklist Set expected retention time When a peak is selected in the drop-down box, the chromatograms for the particular mass windows using the peak width as defined in the peaklist are extracted and displayed. The current rt window is visualized as a green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly.","title":"Manual (interactive) peak optimization"},{"location":"gui/#processing","text":"Run MINT (apply the extraction protocol to all files in the workspace) Download results Reset results and start again When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS files in the workspace and extract additional properties. When the results tables are present, the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button.","title":"Processing"},{"location":"gui/#analysis","text":"After running MINT the results can be downloaded or analyzed using the provided tools. For quality control purposes, histograms and box plots can be generated in the quality control tab. The interactive heatmap tool can be used to explore the results data after RUN MINT has been executed. The tool allows exploring the generated data in form of heatmaps.","title":"Analysis"},{"location":"gui/#general-selection-elements","text":"Include/exclude file types (based on Type column in metadata) Include/exclude peak labels for analysis Set file sorting (e.g. by name, by batch etc.) Select group-by column for coloring and statistics","title":"General selection elements"},{"location":"gui/#heatmap","text":"The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes how the heatmap is generated. Normalized by biomarer: devide values by column maxium. Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time.","title":"Heatmap"},{"location":"gui/#correlation-of-scaled-peak_max","text":"","title":"Correlation of (scaled) peak_max"},{"location":"gui/#distributions","text":"Plot histograms Density distributions Boxplots The MS files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows selecting one or multiple kinds of graphs to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if this type is defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite.","title":"Distributions"},{"location":"gui/#pca","text":"Perform Principal Component Analysis (PCA) Plot projections to first N principal components Contributions of original variables to each component.","title":"PCA"},{"location":"gui/#hierarchical-clustering","text":"","title":"Hierarchical clustering"},{"location":"gui/#plotting","text":"MINT comes with a flexible and powerful plotting interface that is based on the powerful Seaborn library. Bar plots Violin plots Boxen plot Scatter plots and more...","title":"Plotting"},{"location":"install/","text":"Installation Installation with PIP (Linux, MacOS, Windows) The latest release of the program can easily be installed in a standard Python 3 (>= 3.7) environment using the widely used package manager pip : pip install ms-mint The command above should download and install all necessary dependencies and Mint. Mint should then be available via Mint.py Windows Installer For Windows 10 a build is provided here . The installer generates an icon in the windows start menu. There will be a terminal be shown, with potentially some errors due to missing files which can be ignored. Give it some time until the server is running and then navigate to http://localhost:9999 in the browser. Start Mint.py After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. The python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future. Docker MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight and standalone executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries, and settings. Therefore, MINT can run on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest -v /data/:/data/ Then the tool is available in the browser at http://localhost:9999. From source Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installation-with-pip-linux-macos-windows","text":"The latest release of the program can easily be installed in a standard Python 3 (>= 3.7) environment using the widely used package manager pip : pip install ms-mint The command above should download and install all necessary dependencies and Mint. Mint should then be available via Mint.py","title":"Installation with PIP (Linux, MacOS, Windows)"},{"location":"install/#windows-installer","text":"For Windows 10 a build is provided here . The installer generates an icon in the windows start menu. There will be a terminal be shown, with potentially some errors due to missing files which can be ignored. Give it some time until the server is running and then navigate to http://localhost:9999 in the browser.","title":"Windows Installer"},{"location":"install/#start-mintpy","text":"After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. The python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future.","title":"Start Mint.py"},{"location":"install/#docker","text":"MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight and standalone executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries, and settings. Therefore, MINT can run on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest -v /data/:/data/ Then the tool is available in the browser at http://localhost:9999.","title":"Docker"},{"location":"install/#from-source","text":"Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development","title":"From source"},{"location":"jupyter/","text":"Jupyter integration Interactive MINT MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here . Select MS-files from glob import glob mint.ms_files = glob('/path/to/files/*mzML') Select peaklist files mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv' Optimize retention times mint.optimize_retention_times() Run MINT mint.run() Display results That way the results will be readily available for further analysis. mint.results","title":"Jupyter"},{"location":"jupyter/#jupyter-integration","text":"","title":"Jupyter integration"},{"location":"jupyter/#interactive-mint","text":"MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here .","title":"Interactive MINT"},{"location":"jupyter/#select-ms-files","text":"from glob import glob mint.ms_files = glob('/path/to/files/*mzML')","title":"Select MS-files"},{"location":"jupyter/#select-peaklist-files","text":"mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv'","title":"Select peaklist files"},{"location":"jupyter/#optimize-retention-times","text":"mint.optimize_retention_times()","title":"Optimize retention times"},{"location":"jupyter/#run-mint","text":"mint.run()","title":"Run MINT"},{"location":"jupyter/#display-results","text":"That way the results will be readily available for further analysis. mint.results","title":"Display results"},{"location":"peak-detection/","text":"Peak detection Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"peak-detection/#peak-detection","text":"Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"peaklists/","text":"Peaklists A peaklist contains the definitions of peaks to be extracted from the MS files. Peaklists are provided as csv (comma separated values) or xlsx (Microsoft Excel) file. Each row in a peaklist defines a peak-window. If a multi-sheet xlsx file is being used, the peaklist should be the first sheet. A window is defined by five properties that need to be present as headers in the peaklist file:: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label has to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min]. rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value. Example file peaklist.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Peaklists"},{"location":"peaklists/#peaklists","text":"A peaklist contains the definitions of peaks to be extracted from the MS files. Peaklists are provided as csv (comma separated values) or xlsx (Microsoft Excel) file. Each row in a peaklist defines a peak-window. If a multi-sheet xlsx file is being used, the peaklist should be the first sheet. A window is defined by five properties that need to be present as headers in the peaklist file:: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label has to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min]. rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value.","title":"Peaklists"},{"location":"peaklists/#example-file","text":"peaklist.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Example file"},{"location":"python/","text":"Python API The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False) Load files One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv Running Mint Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s Results The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ... Peak shapes The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ... Plotting peak shapes The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint) Export Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Python API"},{"location":"python/#python-api","text":"The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False)","title":"Python API"},{"location":"python/#load-files","text":"One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv","title":"Load files"},{"location":"python/#running-mint","text":"Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s","title":"Running Mint"},{"location":"python/#results","text":"The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ...","title":"Results"},{"location":"python/#peak-shapes","text":"The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ...","title":"Peak shapes"},{"location":"python/#plotting-peak-shapes","text":"The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint)","title":"Plotting peak shapes"},{"location":"python/#export","text":"Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Export"}]}