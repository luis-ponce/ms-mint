{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Metabolomics Integrator MINT (Metabolomics Integrator) is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. The metabolites can be used to define biomarkers used in medicine to find treatments for diseases or for the development of diagnostic tests or for the identification of pathogens such as methicillin resistant Staphylococcus aureus (MRSA). What is LCMS? A typical biological sample, such as human blood or agar with some kind of bacteria, can contain thousands of metabolites such as sugars, alcohols, amino acids, nucleotides and more. To meassure the composition of such a sample mass spectrometry can be used. However, many metabolites share exact masses with other metabolites and therefore would be undistiguishable in the mass spectrometer. Therefore, compounds are sorted using column chromatography and spread out over time. The metabolites that enter the column at the same time interact with the column in different ways based on their specific stereochemistry. These interactions let compounds move faster or slower through the column and therefore the compounds will elude at different times. That way various metabolites can be analysed successively over certain timeframe rather than simultaneously. The mass spectrometer that follows the chromatographic column meassures the masses given at each point in time and returns a time dependent spectrogram. An example of a LSMS meassurement is visualized in the following figure: Figure 1: test bla bla If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or succinic acid ) is shown here: Figure 2: test bla bla This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4. Processing LCMS data After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor specific format the data can be subjected to analysis. To process data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analysing the raw LCMS data it is common practise to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the meassured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiences compound A might have a stronger signal than compound B even if the compound B is present at higher concentration. Therefore, the intensities can only be use to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data anayses such as dimensionality reduction, or clustering analysis. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: _E. coli , SA: S. aureus , CA: C. albicans ). How to use MINT? The tool can be used for targeted analysis where the m/z-values (mass to charge ratios) and chromatographic retention times are known. Alternatively, MINT can be used in an untargeted approach where new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterise measured intensities in a given m/z and retention time (RT) window. These windows can be provided in form of a peaklist or created interactively in the GUI . With this setup large numbers of LCMS-files can be processed automatically, standardized and perfectly reproducible. The tool can be used with a browser based graphical user interface (GUI) implemented as interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as python library to be integrated in any regular Python code as part of a larger processing pipeline or interacively in the Jupyter Notebook .","title":"Background"},{"location":"#metabolomics-integrator","text":"MINT (Metabolomics Integrator) is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. The metabolites can be used to define biomarkers used in medicine to find treatments for diseases or for the development of diagnostic tests or for the identification of pathogens such as methicillin resistant Staphylococcus aureus (MRSA).","title":"Metabolomics Integrator"},{"location":"#what-is-lcms","text":"A typical biological sample, such as human blood or agar with some kind of bacteria, can contain thousands of metabolites such as sugars, alcohols, amino acids, nucleotides and more. To meassure the composition of such a sample mass spectrometry can be used. However, many metabolites share exact masses with other metabolites and therefore would be undistiguishable in the mass spectrometer. Therefore, compounds are sorted using column chromatography and spread out over time. The metabolites that enter the column at the same time interact with the column in different ways based on their specific stereochemistry. These interactions let compounds move faster or slower through the column and therefore the compounds will elude at different times. That way various metabolites can be analysed successively over certain timeframe rather than simultaneously. The mass spectrometer that follows the chromatographic column meassures the masses given at each point in time and returns a time dependent spectrogram. An example of a LSMS meassurement is visualized in the following figure: Figure 1: test bla bla If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or succinic acid ) is shown here: Figure 2: test bla bla This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4.","title":"What is LCMS?"},{"location":"#processing-lcms-data","text":"After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor specific format the data can be subjected to analysis. To process data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analysing the raw LCMS data it is common practise to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the meassured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiences compound A might have a stronger signal than compound B even if the compound B is present at higher concentration. Therefore, the intensities can only be use to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data anayses such as dimensionality reduction, or clustering analysis. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: _E. coli , SA: S. aureus , CA: C. albicans ).","title":"Processing LCMS data"},{"location":"#how-to-use-mint","text":"The tool can be used for targeted analysis where the m/z-values (mass to charge ratios) and chromatographic retention times are known. Alternatively, MINT can be used in an untargeted approach where new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterise measured intensities in a given m/z and retention time (RT) window. These windows can be provided in form of a peaklist or created interactively in the GUI . With this setup large numbers of LCMS-files can be processed automatically, standardized and perfectly reproducible. The tool can be used with a browser based graphical user interface (GUI) implemented as interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as python library to be integrated in any regular Python code as part of a larger processing pipeline or interacively in the Jupyter Notebook .","title":"How to use MINT?"},{"location":"developer-notes/","text":"Developer Notes python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-* Windows executables pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks Documentation deployment mkdocs build && mkdocs gh-deploy","title":"Developer Notes"},{"location":"developer-notes/#developer-notes","text":"python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-*","title":"Developer Notes"},{"location":"developer-notes/#windows-executables","text":"pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks","title":"Windows executables"},{"location":"developer-notes/#documentation-deployment","text":"mkdocs build && mkdocs gh-deploy","title":"Documentation deployment"},{"location":"docker/","text":"","title":"Docker"},{"location":"gui/","text":"Graphical User Interface After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. Thought, the Python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future. Workspaces A workspace is a container for project files that is separated from other workspaces. Through workspaces it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which by default is the folder MINT in the users home directory. The home directory is different on different platforms. Under Windows watch out for C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. DELETE will display a popup window upon confirmation the selected workspace with all corresponding files on the harddrive in --data-dir will be removed. MS-files Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. It is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after convertion. Metadata Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch or by label as well as types. Batch: The batch e.g. plate a particular sample belongs to. Label: A Label such as species. Type: Type of sample, e.g. biological sample, quality control sample, standards Concentration: For standards a concentration value can be provided. The metadata table can be downloaded modified e.g. with Excel and uploaded again. Peaklist Peaklists are collection of peak definitions for the extraction of MS intensities beloning to individual metabolites. Peaklists can be provided as Excel or CSV files. Peaklists are explained in more detail here . Files can be uploaded via the drag and drop area or the selection tool. The peaklist can be edited in place or with the peak optimization tools. Peak Optimization Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the presently loaded peaklist. The GENERATE PEAK PREVIEWS generates a preview of all peak definitions and plots the coresponding chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifes the closest peak with respect to the expected RT which is displayed as black vertical line. When a peak is selected in the drop down box the chromatograms for the particular mass windows using the peak width as defined in the peaklist is extracted and displayed. The current rt window is visualized as green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly. Run MINT When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS-files in the workspace and extract additional properties. When the results tables are present the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button. Quality Control After running MINT the results can be downloaed or analysed using the provided tools. For quality control purposes histograms and boxplots can be generated in the quality control tab. The MS-files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows to select one or multple kinds of graphs that to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if such a type has been defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite. Heatmap The interactive heatmap tool can be used to explore the results data after RUN MINT has been exectuted. The tool allows to explore the generated data in from of heatmaps. The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes the how the heatmap is generated. Normalized by biomarer: Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time.","title":"GUI"},{"location":"gui/#graphical-user-interface","text":"After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. Thought, the Python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future.","title":"Graphical User Interface"},{"location":"gui/#workspaces","text":"A workspace is a container for project files that is separated from other workspaces. Through workspaces it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which by default is the folder MINT in the users home directory. The home directory is different on different platforms. Under Windows watch out for C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. DELETE will display a popup window upon confirmation the selected workspace with all corresponding files on the harddrive in --data-dir will be removed.","title":"Workspaces"},{"location":"gui/#ms-files","text":"Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. It is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after convertion.","title":"MS-files"},{"location":"gui/#metadata","text":"Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch or by label as well as types. Batch: The batch e.g. plate a particular sample belongs to. Label: A Label such as species. Type: Type of sample, e.g. biological sample, quality control sample, standards Concentration: For standards a concentration value can be provided. The metadata table can be downloaded modified e.g. with Excel and uploaded again.","title":"Metadata"},{"location":"gui/#peaklist","text":"Peaklists are collection of peak definitions for the extraction of MS intensities beloning to individual metabolites. Peaklists can be provided as Excel or CSV files. Peaklists are explained in more detail here . Files can be uploaded via the drag and drop area or the selection tool. The peaklist can be edited in place or with the peak optimization tools.","title":"Peaklist"},{"location":"gui/#peak-optimization","text":"Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the presently loaded peaklist. The GENERATE PEAK PREVIEWS generates a preview of all peak definitions and plots the coresponding chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifes the closest peak with respect to the expected RT which is displayed as black vertical line. When a peak is selected in the drop down box the chromatograms for the particular mass windows using the peak width as defined in the peaklist is extracted and displayed. The current rt window is visualized as green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly.","title":"Peak Optimization"},{"location":"gui/#run-mint","text":"When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS-files in the workspace and extract additional properties. When the results tables are present the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button.","title":"Run MINT"},{"location":"gui/#quality-control","text":"After running MINT the results can be downloaed or analysed using the provided tools. For quality control purposes histograms and boxplots can be generated in the quality control tab. The MS-files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows to select one or multple kinds of graphs that to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if such a type has been defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite.","title":"Quality Control"},{"location":"gui/#heatmap","text":"The interactive heatmap tool can be used to explore the results data after RUN MINT has been exectuted. The tool allows to explore the generated data in from of heatmaps. The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes the how the heatmap is generated. Normalized by biomarer: Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time.","title":"Heatmap"},{"location":"install/","text":"Installation Download (Windows) For Windows 10 a build is provided here . Simply, unpack the zip-archive and start Mint.exe . Then navigate to http://localhost:9999 if the browser does not open automatically. With PyPI (recommended) The program can be installed in a Python 3 (>= 3.7) environment using pip : pip install ms-mint From source Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development Launching the GUI The browser based GUI can then be started with conda activate ms-mint # if you run MINT in an Anaconda environment Mint.py Then navigate to the following ULR with your browser: http://localhost:9999/ . More information is available in the GUI section. Docker MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. This allows to run MINT on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest Then the tool is available in the browser at http://localhost:9999.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#download-windows","text":"For Windows 10 a build is provided here . Simply, unpack the zip-archive and start Mint.exe . Then navigate to http://localhost:9999 if the browser does not open automatically.","title":"Download (Windows)"},{"location":"install/#with-pypi-recommended","text":"The program can be installed in a Python 3 (>= 3.7) environment using pip : pip install ms-mint","title":"With PyPI (recommended)"},{"location":"install/#from-source","text":"Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development","title":"From source"},{"location":"install/#launching-the-gui","text":"The browser based GUI can then be started with conda activate ms-mint # if you run MINT in an Anaconda environment Mint.py Then navigate to the following ULR with your browser: http://localhost:9999/ . More information is available in the GUI section.","title":"Launching the GUI"},{"location":"install/#docker","text":"MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. This allows to run MINT on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest Then the tool is available in the browser at http://localhost:9999.","title":"Docker"},{"location":"jupyter/","text":"Jupyter integration Interactive MINT MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here . Select MS-files from glob import glob mint.ms_files = glob('/path/to/files/*mzML') Select peaklist files mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv' Optimize retention times mint.optimize_retention_times() Run MINT mint.run() Display results That way the results will be readily available for further analysis. mint.results","title":"Jupyter"},{"location":"jupyter/#jupyter-integration","text":"","title":"Jupyter integration"},{"location":"jupyter/#interactive-mint","text":"MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here .","title":"Interactive MINT"},{"location":"jupyter/#select-ms-files","text":"from glob import glob mint.ms_files = glob('/path/to/files/*mzML')","title":"Select MS-files"},{"location":"jupyter/#select-peaklist-files","text":"mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv'","title":"Select peaklist files"},{"location":"jupyter/#optimize-retention-times","text":"mint.optimize_retention_times()","title":"Optimize retention times"},{"location":"jupyter/#run-mint","text":"mint.run()","title":"Run MINT"},{"location":"jupyter/#display-results","text":"That way the results will be readily available for further analysis. mint.results","title":"Display results"},{"location":"peak-detection/","text":"Peak detection Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"peak-detection/#peak-detection","text":"Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"peaklists/","text":"Peaklists A peaklist contains the definitions of peaks to be extracted. It is the protocol that captures how data is going to be extracted from the MS-files. It is provided as csv (comma separated values) or xlsx (Microsoft Excel) file. Each row defines a peak-window. If a multi-sheet xlsx file can be used the peaklist should be the first sheet. A window is defined by five properties that need to be present as headers in the peaklist file: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label have to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min]. rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value. Example file peaklist.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Peaklists"},{"location":"peaklists/#peaklists","text":"A peaklist contains the definitions of peaks to be extracted. It is the protocol that captures how data is going to be extracted from the MS-files. It is provided as csv (comma separated values) or xlsx (Microsoft Excel) file. Each row defines a peak-window. If a multi-sheet xlsx file can be used the peaklist should be the first sheet. A window is defined by five properties that need to be present as headers in the peaklist file: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label have to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min]. rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value.","title":"Peaklists"},{"location":"peaklists/#example-file","text":"peaklist.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Example file"},{"location":"python/","text":"Python API The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False) Load files One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv Running Mint Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s Results The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ... Peak shapes The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ... Plotting peak shapes The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint) Export Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Python API"},{"location":"python/#python-api","text":"The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False)","title":"Python API"},{"location":"python/#load-files","text":"One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv","title":"Load files"},{"location":"python/#running-mint","text":"Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s","title":"Running Mint"},{"location":"python/#results","text":"The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ...","title":"Results"},{"location":"python/#peak-shapes","text":"The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ...","title":"Peak shapes"},{"location":"python/#plotting-peak-shapes","text":"The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint)","title":"Plotting peak shapes"},{"location":"python/#export","text":"Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Export"}]}